/*
 * =====================================================================================
 *
 *       Filename: libnvc.hpp
 *        Created: 12/27/2018 04:52:17
 *    Description: 
 *
 *        Version: 1.0
 *       Revision: none
 *       Compiler: gcc
 *
 *         Author: ANHONG
 *          Email: anhonghe@gmail.com
 *   Organization: USTC
 *
 * =====================================================================================
 */

#pragma once

#include "log.hpp"
#include "valdef.hpp"
#include "objdef.hpp"
#include "typedef.hpp"

#include "socket.hpp"
#include "asiosocket.hpp"

#include "apiclient.hpp"
#include "guiclient.hpp"

namespace libnvc::ctf
{
    constexpr size_t strlen(const char *str)
    {
        size_t index = 0;
        while(str[index] != '\0'){
            ++index;
        }
        return index;
    }

    constexpr int strcmp(const char *str1, const char *str2)
    {
        for(size_t index = 0;; ++index){
            if(str1[index] < str2[index]){
                return -1;
            }

            if(str1[index] > str2[index]){
                return 1;
            }

            if(str1[index] == '\0'){
                return 0;
            }
        }
    }

    constexpr int strncmp(const char *str1, const char *str2, size_t size)
    {
        for(size_t index = 0; index < size; ++index){
            if(str1[index] < str2[index]){
                return -1;
            }

            if(str1[index] > str2[index]){
                return 1;
            }

            if(str1[index] == '\0'){
                return 0;
            }
        }
    }

    constexpr int chmemcmp(const char *mem1, const char *mem2, size_t size)
    {
        for(size_t index = 0; index < size; ++index){
            if(mem1[index] < mem2[index]){
                return -1;
            }

            if(mem1[index] > mem2[index]){
                return +1;
            }
        }
        return 0;
    }

    constexpr void chmemset(char *dst, char value, size_t size)
    {
        for(size_t index = 0; index < size; ++index){
            dst[index] = value;
        }
    }

    constexpr char *strcat(char *dst, const char *src)
    {
        size_t index  = 0;
        size_t length = libnvc::ctf::strlen(dst);

        for(index = 0; src[index] != '\0'; ++index){
            dst[length + index] = src[index];
        }

        dst[length + index] = '\0';
        return dst;
    }
}

namespace libnvc
{
    constexpr const char * g_nvim_reserved_api_string_tbl[]
    {
        // put the zero index as reserved
        // only allow the first entry as nullptr
        nullptr,

        // #begin don't modify
        // #begin generated by jinja2
{% for req in nvim_reqs %}
        "req::{{req.name}},"
{% endfor %}
        // #end don't modify
        // #end generated by jinja2

        // notifications
        "notif::test",
    };

    constexpr const char *idstr(size_t id)
    {
        if(id == 0 || id >= std::extent<decltype(g_nvim_reserved_api_string_tbl)>::value){
            return nullptr;
        }
        return g_nvim_reserved_api_string_tbl[id];
    }

    constexpr size_t strid(const char *str)
    {
        if(str == nullptr){
            return 0;
        }

        for(size_t index = 1; index < std::extent<decltype(g_nvim_reserved_api_string_tbl)>::value; ++index){
            if(libnvc::ctf::strcmp(str, g_nvim_reserved_api_string_tbl[index]) == 0){
                return index;
            }
        }
        return 0;
    }

    constexpr size_t strid(const char *prefix, const char *name)
    {
        char buf[512] = {'\0'};
        libnvc::ctf::strcat(buf, prefix);
        libnvc::ctf::strcat(buf, "::"  );
        libnvc::ctf::strcat(buf, name  );
        return libnvc::strid(buf);
    }

    constexpr size_t reqid(const char *req_name)
    {
        return strid("req", req_name);
    }

    constexpr size_t notifid(const char *notif_name)
    {
        return strid("notif", notif_name);
    }

    constexpr size_t min_reqid()
    {
        if(str == nullptr){
            return 0;
        }

        for(size_t id = 1; libnvc::idstr(id) != nullptr; ++id){
            if(libnvc::ctf::strncmp(libnvc::idstr(id), "req::", 5) == 0){
                return id;
            }
        }
        return 0;
    }

    constexpr size_t max_reqid(const char *str)
    {
        if(str == nullptr){
            return 0;
        }

        for(size_t id = std::extent<decltype(g_nvim_reserved_api_string_tbl)>::value - 1; libnvc::idstr(id) != nullptr; --id){
            if(libnvc::ctf::strncmp(libnvc::idstr(id), "req::", 5) == 0){
                return id;
            }
        }
        return 0;
    }

    constexpr size_t min_notifid()
    {
        if(str == nullptr){
            return 0;
        }

        for(size_t id = 1; libnvc::idstr(id) != nullptr; ++id){
            if(libnvc::ctf::strncmp(libnvc::idstr(id), "notif::", 5) == 0){
                return id;
            }
        }
        return 0;
    }

    constexpr size_t max_notifid(const char *str)
    {
        if(str == nullptr){
            return 0;
        }

        for(size_t id = std::extent<decltype(g_nvim_reserved_api_string_tbl)>::value - 1; libnvc::idstr(id) != nullptr; --id){
            if(libnvc::ctf::strncmp(libnvc::idstr(id), "notif::", 5) == 0){
                return id;
            }
        }
        return 0;
    }
}

namespace libnvc
{
    struct nil_type
    {
        int unused = 0;
    };

    using nil_t = struct nil_type;
    using object = std::variant<libnvc::nil_t,
{% for result_type in nvim_reqs|map(attribute='return_type')|unique %}
    {% if result_type != 'void' %}
        {{result_type}}{% if not loop.last %},{% endif %} 
    {% endif %}
{% endfor %}
    >;
}
