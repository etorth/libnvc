/*
 * =====================================================================================
 *
 *       Filename: reqdef.jinja2.hpp
 *        Created: 12/28/2018 03:25:41
 *    Description: 
 *
 *        Version: 1.0
 *       Revision: none
 *       Compiler: gcc
 *
 *         Author: ANHONG
 *          Email: anhonghe@gmail.com
 *   Organization: USTC
 *
 * =====================================================================================
 */

#pragma once
#include <cstdint>
#include <variant>
#include "ctf.hpp"
#include "valdef.hpp"
#include "objdef.hpp"
#include "typedef.hpp"

namespace libnvc
{
    // don't modify
    // entries generated by jinja2

    constexpr static const char * g_nvim_api_string_tbl[]
    {
        // put the zero index as reserved
        nullptr,

        // requests
{% for req in nvim_reqs %}
        "req::{{req.name}},"
{% endfor %}

        // notifications
        "notif::test",
    };

    inline constexpr const char *idstr(size_t id)
    {
        if(id == 0 || id >= std::extent<decltype(g_nvim_api_string_tbl)>::value){
            return nullptr;
        }
        return g_nvim_api_string_tbl[id];
    }

    inline constexpr size_t strid(const char *str)
    {
        if(str == nullptr){
            return 0;
        }

        for(size_t index = 1; index < std::extent<decltype(g_nvim_api_string_tbl)>::value; ++index){
            if(libnvc::ctf::strcmp(str, g_nvim_api_string_tbl[index]) == 0){
                return index;
            }
        }
        return 0;
    }
}

namespace libnvc
{
    constexpr size_t strid(const char *prefix, const char *name)
    {
        char buf[512] = {'\0'};
        libnvc::ctf::strcat(buf, prefix);
        libnvc::ctf::strcat(buf, "::"  );
        libnvc::ctf::strcat(buf, name  );
        return libnvc::strid(buf);
    }

    constexpr size_t reqid(const char *req_name)
    {
        return strid("req", req_name);
    }

    constexpr size_t respid(const char *resp_name)
    {
        return strid("resp", resp_name);
    }

    constexpr size_t notifid(const char *notif_name)
    {
        return strid("notif", notif_name);
    }

    constexpr size_t min_reqid()
    {
        for(size_t id = 1;; ++id){
            if(auto str = libnvc::idstr(id); str && (libnvc::ctf::strlen(str) >= 5)){
                if(libnvc::ctf::strncmp(str, "req::", 5) == 0){
                    return id;
                }
            }
        }
        return 0;
    }

    constexpr size_t max_reqid()
    {
        for(size_t id = 1;; ++id){
            if(auto str = libnvc::idstr(id); str && (libnvc::ctf::strlen(str) >= 5)){
                if(libnvc::ctf::strncmp(str, "req::", 5) == 0){
                    return id;
                }
            }
        }
        return 0;
    }
}

namespace libnvc
{
    // we only allow explicit declared req<i>
    // for undefined i just trigger a compilation error
    template<size_t> struct req;

{% for req in nvim_reqs %}
    template<> struct req<libnvc::reqid("{% req.name %}")>
    {
        using parms_t = struct
        {
{% for arg in req.args %}
            {{arg.type}} {{arg.name}};
{% endfor %}
            std::string pack(int64_t) const;
        };

        using res_t = {{req.return_type}};

        constexpr int since() const
        {
            return {{req.since}};
        }

        constexpr int deprecated() const
        {
            return {{req.deprecated}};
        }

        constexpr auto id() const
        {
            return libnvc::strid("req::{{req.name}}");
        }

        constexpr auto name() const
        {
            return libnvc::idstr(id());
        }
    };
{% endfor %}
}
